        CISC 372  *  Spring 2020  *  Homework #2

Released: Tuesday, Feb. 25
Due: Friday, Mar. 6 , 10:00 PM.


==== ==== Directions ==== ====

Directions: Create a directory named hw2 in your private Git repository

But be sure to NOT add any *generated* files, such as anything
generated by the compiler, i.e., no executable files, no object files,
no output, etc. You will lose SIGNIFICANT points for including
such files in your submissions.

Periodically, you should commit and push your work, which is how the
changes in your local copy are sent back to our serverrepository. Make
sure to add your new or modified files first using 'git add'. You can list
files individually like so:

git add file1 file2

OR use the following command to add all new or modified files:

git add -A

To check which files are staged (i.e. to be committed) type

git status

Files or changes to files will only be committed if they are listed
under the "Changes to be committed" section. "Untracked files" and files
listed under "Changes not staged for commit" will not be committed.
Here is where you can DOUBLE CHECK that binary files are never included
in the "Changes to be committed" section.
Remember to use the following command to commit your changes:

git commit

You will enter a text editor, where you should enter and save a log
message when prompted.  This will commit all staged files that you added
with 'git add'. The last step is to push your commit(s) so that the git
server has an updated copy of your work. Use the following command to push:

git push

You should commit and push early and often, to make sure you don't lose work,
and also because you might want to work on different machines which must be
kept in sync.

(You can control which editor is used for editing the commit message using
the following command:

git config --global core.editor "vim"

This will ensure that Git will use vim for all of your commits. If you wish to
use emacs, change "vim" to "emacs".)

If you have a short log message and don't want or need to go through
an editor to enter your log message, you can use the -m option:

git commit -m "Added a Makefile and fixed a small bug."

To summarize: you must use "git add" to add new files and modified files you
wish to commit. Once they have been added, use "git commit" to commit your 
changes, and when you run "git push" your changes will be sent back to the Git
server for the instructors to see.

REMEMBER: if you don't add it, commit it, and push it, you haven't submitted it.
And be sure to commit and push your final work.  It is your last commit/push 
before the deadline that will "count" when we grade.


==== ==== Problem 1: types ==== ====

Files involved in this problem:
  README

Create a subdirectory of hw2 called types.
Answer the following questions in a plain text file
named README within the types directory.

Write the English names of the following types:

(a) unsigned long int (*[])[n]
(b) int * *
(c) double *[n1][n2][n3];

(d) In a C program, a function call is evaluated by assigning the
value of each argument to the corresponding formal parameter.  For
example, in the following code

int f(int x) { ... }
int y=7;
f(y);

the int value 7 is assigned to the formal parameter x.  The formal
parameter x consumes sizeof(int) bytes of memory, so this part of the
call essentially involves copying sizeof(int) bytes of data.

Consider the following C code:

void f(int x[n]) { ... }
...
int a[1000000]; // one million ints
f(a);

How many bytes of data are copied in the call when the value of the
argument is assigned to x?  Your answer should be a C expression.


Your README file should contain just the answers, and look like this:

(a) this-is-the-name-of-the-type
(b) this-is-the-name-of-the-second-type
(c) yet-another-type
(d) some C expression here

Nothing else should go in the file.



==== ==== Problem 2: ragged ==== ====

Files involved in this problem:
  Makefile
  ragged.c

Create a directory ragged.  In this directory you will construct
a simple C program in a single file:

   ragged.c, a C program that takes a sequence of integers
             on the command line and constructs a ragged
             2d-array.

Take a look at the "starter files" porivded in this repository;
they include a Makefile and a "skeleton" version of ragged.c
You can copy these and use them as your starting point.

Say the number of (integer) command line arguments is n.

The program should have global variables:

  lengths. Type: pointer-to-int
  data. Type: pointer-to-pointer-to int.

Memory should be allocated and variables initialized so that:

lengths[0], ..., lengths[n-1] are the given command line arguments.

For each i in [0,n), data[i] points to the first int in a sequence of
lengths[i] ints.

The int values of data should be initialized using the consecutive
integers starting from 0 (with no gaps or repeats), first initializing
row 0, then row 1, etc.

The program should then print data using one line for each row and a
single space to separate the ints in a row.

The program should then deallocate all allocated memory and terminate.

Examples:

> ./ragged.exe 1 2 3
0
1 2
3 4 5
>

> ./ragged.exe 4 1 2 2 3
0 1 2 3
4
5 6
7 8
9 10 11
>


A Makefile is provided, but it is highly recommended that you add more
tests to it.

Example:

In Makefile add:

testX : ragged.exe
    ./ragged.exe 2 5 1 4 3

And then execute "make testX".



==== ==== Problem 3: evens ==== ====

Create a directory "evens".

Files involved in this problem:
  Makefile
  evens_lib.h
  evens_lib.c
  evens_driver.c

In this problem you will develop a more complex C program
spread out over 3 files:

  1. evens_lib.h, a header file containing prototypes for 2 functions
  2. evens_lib.c, containing the implementations of those 2 functions
  3. evens_driver.c, containing a simple command line driver

In this Git repository you will see skeleton versions of all three
files.  You can use them as a starting point.

File evens_lib.h:
  this is a simple header file and the starter file should basically
  be complete.  Read it.

File evens_lib.c:

The first function to implement is find_evens:

int * find_evens(int * p, int n, int * num_evens);

This function consumes a pointer p which points to some sequence of
ints of length at least n.  It creates a new array consisting of only
the even numbers from those n ints.  The even numbers occur in the
same order as in the original array.  (In other words, the new array
is obtained by removing the odd numbers from the original array.)  The
length of the new array (i.e., the number of even numbers) is assigned
to the memory location pointed to by num_evens.  The function returns
a pointer to element 0 of the new array (consisting of the even
numbers).

Note: the memory allocated for new_array should be exactly the amount
of memory required to store num_evens ints.  Do not allocate more
memory than that.

Note: the function should not modify the data pointed to by p
(i.e., the original sequence).

In case there are no even numbers in the given sequence, the function
should return NULL (and not allocate anything).

The second function is a simple function to print the elements of an
int array.  Its implementation is provided for you in the starter
file.


File evens_driver.c:

This is where you put the main function.  The main function should
enable the user to invoke the program on a list of ints and the
program should then print the even ones.  For example, the user could
invoke the program and get a response as follows:

> ./evens.exe 1 2 3 4 5
The even numbers are: 2 4

Don't forget that the first command line argument is argv[1]; argv[0]
is always the name of the program!.

The main function should parse the command line arguments, construct
an array of ints, invoke find_evens on it, and print the result
exactly as above using the function to print an int array.

In case there are no even numbers given, the program should print

The even numbers are:

A Makefile is provided, but it is highly recommended that you add more
tests to it.



==== ==== Problem 4 (EXTRA CREDIT): poker ==== ====

This problem is optional and is worth 20 bonus points.

Create a directory "poker".  In this exercise you will create a
representation of a poker hand and estimate the probability of a
straight flush.

Files to commit:
  poker.c
  README
  Makefile

A suit is one of Diamonds, Clubs, Hearts, or Spades.
Create an enumeration for suit and call the resulting type Suit:

typedef enum suit_s {DIAMONDS, CLUBS, HEARTS, SPADES} Suit;

A card consists of a suit and a rank. The rank is an integer between 1
and 13, inclusive. A 1 represents an Ace, an 11 represents a Jack, a
12 Queen, a 13 King.

Create a structure to represent a card.  It should look something like
this:

typedef struct card_s {
  int rank;
  Suit suit;
} * Card;


Then develop functions to: create a random card, print a card, and
destroy (deallocate) a card.  Look up the rand() function for getting
random numbers.  Also create a function to determine whether two cards
are equal.

A hand consists of five *distinct* cards.  Create a structure to
represent a hand, and functions to create a random hand, print a hand,
and destroy (deallocate) a hand.  Re-use the functions for cards.

Write a function to determine whether a hand is a straight flush.  A
hand is a straight flush if both of the following are satisfied: (1)
all 5 cards of the hand have the same suit, and (2) the ranks of the
cards form a sequence of consecutive integers.  However, for (2), the
Ace (1) can count as EITHER 1 (the lowest rank), or as "14" (the
highest rank), but NOT BOTH.  For example, 1,2,3,4,5 is fine, as is
10,11,12,13,1.  But not 11,12,13,1,2.

Create functions to test all of the above.

Finally, for your main function: take one command line input, the
number of trials.  Then iterate #trials times.  At each iteration,
generate a random hand, determine if it is a straight flush, increment
a counter if so, and destroy the hand.  At the end print out both the
total number of straight flushes encountered, and the fraction (a
number between 0 and 1) of the hands that were straight flushes.

Create a Makefile with rules run (which will execute the program with
1000000 hands), poker (generates the executable named "poker"), and
clean.

Using your program, come up with the best estimate you can for the
probability of receiving a straight flush in a random hand.  Put your
